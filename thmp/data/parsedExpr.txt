assert[there, [pair, [[consisting of], MathObj{$f, g$}]], exists]
[nulllet]
MathObj{$(m_i, \mu_{ij})$}
MathObj{$(n_i, \nu_{ij})$}
MathObj{systems, of MathObj{$r$-modules}, over [MathObj{set, partially ordered, same}]}
MathObj{morphism, of MathObj{systems}}
expr[$\phi = (\phi_i)$]
[from]
assert[MathObj{$(m_i, \mu_{ij})$, to [MathObj{$(n_i, \nu_{ij})$}]}, MathObj{homomorphism, $$ \colim \phi_i : \colim m_i \longrightarrow \colim n_i $$, unique, such that [MathObj{$$ \xymatrix{ m_i \ar[r] \ar[d]_{\phi_i} & \colim m_i \ar[d]^{\colim \phi_i} \\ n_i \ar[r] & \colim n_i } $$}]}, induces]
]
[[for all], MathObj{$i \in i$}]
parti[filtered]
assert[MathObj{colimits}, exact, are]
]
assert[symb[$i$], MathObj{set, partially ordered},  type: be, be]
MathObj{$(l_i, \lambda_{ij})$}
MathObj{$(m_i, \mu_{ij})$}
and[and]
MathObj{$(n_i, \nu_{ij})$}
MathObj{systems, of MathObj{$r$-modules}, over [[$i$]]}
letbe[conj_ent[MathObj{$\varphi_i : l_i \to m_i$}, MathObj{$\psi_i : m_i \to n_i$}], MathObj{morphisms, of MathObj{systems}, over [[$i$]]}]
]
[that]
[[for all], assert[MathObj{$i \in i$ sequence, of MathObj{$r$-modules, $$ \xymatrix{ l_i \ar[r]^{\varphi_i} & m_i \ar[r]^{\psi_i} & n_i } $$}}, [MathObj{complex}, [with, MathObj{homology, $h_i$}]], is]]
then]
MathObj{$r$-modules, $h_i$}
MathObj{system form, over [[$i$]]}
assert[MathObj{sequence, of MathObj{$r$-modules, $$ \xymatrix{ \colim_i l_i \ar[r]^\varphi & \colim_i m_i \ar[r]^\psi & \colim_i n_i } $$}}, [MathObj{complex}, [as, MathObj{well}]], is]
and[and]
gerund[denoting]
symb[$h$]
[its]
MathObj{homology}
assert[[we, homology], assert[$$ h = \colim_i h_i. $$], have]
letbe[MathObj{$\mathcal{i}$}]]
MathObj{category}]
gerund[satisfying]
MathObj{assumptions of categories}
[lemma]
then]
gerund[taking]
assert[MathObj{colimits, of MathObj{diagrams, of MathObj{abelian groups}}, over [MathObj{$\mathcal{i}$}]}, exact, is]
[(i]
[.e]
[analogue]
[of]
assert[lemma, in, holds]
[this]
[situation)]
letbe[symb[$r$], MathObj{ring, $r$}]
letbe[symb[$m$], MathObj{$r$-module, $m$}]
conj_ent[MathObj{$n \geq 0$}, MathObj{$x_i \in m$}]
[for]
expr[$i = 1, \ldots, n$]
assert[np[relation, [between, MathObj{$x_1, \ldots, x_n$, in [[$m$, $r$-module]]}]], MathObj{sequence, of MathObj{elements, $f_1, \ldots, f_n \in r$}, such that [[$\sum_{i = 1, \ldots, n} f_i x_i = 0$]]}, is]
conj_letbe[letbe[symb[$r$, ring], MathObj{ring, $r$}], letbe[symb[$m$, $r$-module], MathObj{$r$-module, $m$}]]
thenassert[symb[$m$, $r$-module], [MathObj{colimit, of MathObj{system, $(m_i, \mu_{ij})$, directed, of MathObj{$r$-modules}}}, [with, MathObj{$m_i$, all, finitely presented}]], is]
MathObj{$r$-modules}
letbe[symb[$r$, ring], MathObj{ring, $r$}]
MathObj{subset, $s$, of [$r$]}
assert[symb[$s$, subset], conj_assert[assert[MathObj{subset, multiplicative, of [$r$]}, MathObj{$1\in s$}, is], assert[symb[$s$, subset], closed, is]], is]]
[multiplication]
symb[i]
[.e]
MathObj{$s, s' \in s \rightarrow ss' \in s$}
MathObj{ring, this}
]
MathObj{localization, of [$a$]}
[with]
[to, symb[$s$, subset]]]
assert[assert[MathObj{localization, $s^{-1}a$}, MathObj{zero ring}, is], [if and only if], is]
MathObj{$0\in s$}
letbe[symb[$r$, ring], MathObj{ring, $r$}]
letbe[MathObj{$s \subset r$}, MathObj{subset, multiplicative}]
assert[MathObj{category, of MathObj{$s^{-1}r$-modules}}, [[[equivalent, [to, MathObj{category, of MathObj{$r$-modules, $n$}}]], [with, np[property, phrase[that, assert[MathObj{$s \in s$, every}, [as, MathObj{automorphism}], acts]]]]], [on, symb[$n$, $r$-modules]]], acts]
assert[MathObj{$s^{-1}a$-module, $s^{-1}m$}, MathObj{localization, of [$m$], at [[$s$, subset]]}, is called]
letbe[symb[$r$, ring], MathObj{ring, $r$}]
MathObj{$s \subset r$, multiplicative}MathObj{subset}
symb[$m$, $r$-module]
symb[$n$]
MathObj{$r$-modules}
assert[MathObj{elements, all, of [$s$]}, [[as, MathObj{automorphisms}], [on, symb[$n$, $r$-modules]]], act]]
then]
MathObj{map, $$ \hom_r(s^{-1}m, n) \longrightarrow \hom_r(m, n) $$, canonical, induced by [MathObj{localization map}]}
MathObj{isomorphism}]
letbe[symb[$r$, ring], MathObj{ring, $r$}]
letbe[MathObj{$s \subset r$}, MathObj{subset, multiplicative}]
letbe[symb[$m$, $r$-module], MathObj{$r$-module, $m$}]
thenassert[$$ s^{-1}m = \colim_{f \in s} m_f $$]
[partial]]
[ordering on]
assert[symb[$s$, subset], [[phrase[partiby[given by], expr[$f \geq f' \leftrightarrow f = f'f''$]], [for, MathObj{$f'' \in r$, some}]], [in, phrase[which, assert[MathObj{map case, $m_{f'} \to m_f$}, MathObj{$m/(f')^e \mapsto m(f'')^e/f^e$}, is]]]], is]
assert[MathObj{localization}, MathObj{quotients}, respects]
symb[i]
[.e]
if]
symb[$n$, $r$-modules]
]
MathObj{submodule, of [$m$]}
then]
MathObj{$s^{-1}(m/n)\simeq (s^{-1}m)/(s^{-1}n)$}
assert[MathObj{submodule, $n'$, any, of MathObj{$s^{-1}m$}}, [MathObj{$s^{-1}n$ form}, [for, MathObj{$n\subset m$, some}]], is of]
[one]
]
[MathObj{$n$as inverse image, of MathObj{$n'$}}], [in, symb[$m$, $r$-module]]]
assert[MathObj{ideals, in [MathObj{localization, of MathObj{ring}}]}, MathObj{localizations, of MathObj{ideals}}, are]
assert[MathObj{ideal, $i'$, each, of MathObj{$s^{-1}a$}}, MathObj{$s^{-1}i$ form}, takes]
[one]]
]
[MathObj{$i$as inverse image, of MathObj{$i'$}}], [in, symb[$a$]]]
[exactness]
and[and]
MathObj{$\hom_r$}
letbe[symb[$r$, ring], MathObj{ring, $r$}]
letbe[MathObj{$m_1 \to m_2 \to m_3 \to 0$}, MathObj{complex, of MathObj{$r$-modules}}]
thenassert[MathObj{$m_1 \to m_2 \to m_3 \to 0$}, exact, is]
ifstate[[if and only if], assert[MathObj{$0 \to \hom_r(m_3, n) \to \hom_r(m_2, n) \to \hom_r(m_1, n)$}, exact, is]]
[[for all], MathObj{$r$-modules, $n$}]
letbe[MathObj{$0 \to m_1 \to m_2 \to m_3$}, MathObj{complex, of MathObj{$r$-modules}}]
thenassert[MathObj{$0 \to m_1 \to m_2 \to m_3$}, exact, is]
ifstate[[if and only if], assert[MathObj{$0 \to \hom_r(n, m_1) \to \hom_r(n, m_2) \to \hom_r(n, m_3)$}, exact, is]]
[[for all], MathObj{$r$-modules, $n$}]
letbe[symb[$r$, ring], MathObj{ring, $r$}]
letbe[symb[$m$, $r$-module], MathObj{$r$-module, $m$, finitely presented}]
letbe[symb[$n$, $r$-modules], MathObj{$r$-module, $n$}]
[for, MathObj{$f \in r$}]
assert[[we, $f \in r$], assert[$\hom_r(m, n)_f = \hom_{r_f}(m_f, n_f) = \hom_r(m_f, n_f)$], have]
[for]
MathObj{subset, $s$, multiplicative, of [$r$]}
assert[[we, subset], assert[$$ s^{-1}\hom_r(m, n) = \hom_{s^{-1}r}(s^{-1}m, s^{-1}n) = \hom_r(s^{-1}m, s^{-1}n). $$], have]
letbe[symb[$r$, ring], MathObj{ring, $r$}]
MathObj{$m, n, p$}
MathObj{$r$-modules, three}
MathObj{mapping, $f : m \times n \to p$}
[(where]
assert[MathObj{$m \times n$}, [only, [as, MathObj{product, cartesian, of MathObj{$r$-modules), two}}]], is viewed]
]
[saidas]
MathObj{$r$-bilinear}
If[[for each], assert[MathObj{$x \in m$ mapping, $y\mapsto f(x, y)$, of [$n$], into [[$p$]]}, MathObj{$r$-linear}, is]]
and[and]
[[for each], assert[MathObj{$y\in n$ mapping, $x\mapsto f(x, y)$}, [also, MathObj{$r$-linear}], is]]
letbe[MathObj{$m, n$}, MathObj{$r$-modules}]
thenassert[there, assert[MathObj{$(t, g)$ pair, where [[$t$]]}, MathObj{$r$-module}, is], is]
and[and]
MathObj{$g : m \times n \to t$, $r$-bilinear mapping}
[with]
gerundp[gerundfollowing, [universal property]]
[:]
[for, conj_ent[MathObj{$r$-module, $p$, any}, MathObj{$r$-bilinear mapping, $f : m \times n \to p$, any}]]
assert[there, MathObj{$r$-linear mapping, $\tilde{f} : t \to p$, unique, such that [[$f = \tilde{f} \circ g$]]}, exists]
[other words]
gerund[following]
MathObj{diagram}
]
[:]
MathObj{$$ \xymatrix{ m \times n \ar[rr]^f \ar[dr]_g & & p\\ & t \ar[ur]_{f'} } $$}
Ifassert[conj_ent[MathObj{$(t, g)$}, MathObj{$(t', g')$}], [two pairs], are]
[property, this]
thenassert[there, MathObj{isomorphism, $j : t \to t'$, unique, such that [[$j\circ g = g'$]]}, exists]
letbe[MathObj{$m, n, p$}, MathObj{$r$-modules}]
thenassert[MathObj{maps, $$ (x, y) & \mapsto y \otimes x\\ (x + y, z) & \mapsto x \otimes z + y \otimes z\\ (r, x) & \mapsto rx $$, bilinear}, MathObj{isomorphisms, $$ m \otimes_r n & \to n \otimes_r m, \\ (m\oplus n)\otimes_r p & \to (m \otimes_r p)\oplus(n \otimes_r p), \\ r \otimes_r m & \to m $$, unique}, induce]
letbe[MathObj{$m_1, \ldots, m_r$}, MathObj{$r$-modules}]
thenassert[there, [MathObj{$(t, g)$ pair}, [[consisting of], conj_ent[MathObj{$r$-module, t}, MathObj{$r$-multilinear mapping, $g : m_1\times \ldots \times m_r \to t$}]]], exists]
[:]
[for, MathObj{$r$-multilinear mapping, $f : m_1\times \ldots \times m_r \to p$, any}]
assert[there, MathObj{$r$-module homomorphism, $f' : t \to p$, unique, such that [[$f'\circ g = f$]]}, exists]
[such]
assert[MathObj{module, $t$}, [unique, [[up to], MathObj{isomorphism, unique}]], is]
assert[we, it, denote]
MathObj{$m_1\otimes_r \ldots \otimes_r m_r$}
and[and]
assert[[we, $m_1\otimes_r \ldots \otimes_r m_r$], universal, denote]
[multilinear]
MathObj{map, $(m_1, \ldots, m_r) \mapsto m_1 \otimes \ldots \otimes m_r$}
MathObj{homomorphisms, $$ (m \otimes_r n)\otimes_r p \to m \otimes_r n \otimes_r p \to m \otimes_r (n \otimes_r p) $$, such that [conj_assert[[$f((x \otimes y)\otimes z) = x \otimes y \otimes z$], [$g(x \otimes y \otimes z) = x \otimes (y \otimes z)$]]]}
assert[MathObj{$x\in m, y\in n, z\in p$}, [conj_verb]], MathObj{isomorphisms}], are]
assert[MathObj{abelian group, $n$}, MathObj{$(a, b)$-bimodule if it is both $a$-module and $b$-module}, is called]
and[and]
assert[conj_ent[MathObj{actions, $a \to end(m)$}, MathObj{$b \to end(m)$}], compatible, are]
phrase[that, assert[$(ax)b = a(xb)$]]
[[for all], MathObj{$a\in, b\in b, x\in n$}]
adverb[usually]
assert[we, [it, [as, MathObj{$_an_b$}]], denote]
[for, MathObj{$a$-module, $m$}]
conj_ent[MathObj{$b$-module, $p$}, MathObj{$(a, b)$-bimodule $n$}]
assert[conj_ent[MathObj{modules, $(m \otimes_a n)\otimes_b p$}, MathObj{$m \otimes_a(n \otimes_b p)$}], assert[both, MathObj{$(a, b)$-bimodule structure},  type: be, be],  type: be, be]
and[and]
MathObj{$$ (m \otimes_a n)\otimes_b p \cong m \otimes_a(n \otimes_b p). $$}
[for, MathObj{$r$-modules, $m, n, p$, any three}]
MathObj{$$ \hom_r(m \otimes_r n, p) \cong \hom_r(m, \hom_r(n, p)) $$}
[for, MathObj{$r$-modules, $m, n, p$, any three}]
MathObj{$$ \hom_r(m \otimes_r n, p) \cong \hom_r(m, \hom_r(n, p)) $$}
letbe[MathObj{$$ m_1\xrightarrow{f} m_2\xrightarrow{g} m_3 \to 0 $$}, conj_ent[MathObj{sequence, exact, of MathObj{$r$-modules}}, MathObj{homomorphisms}]]
and[and]
letbe[symb[$n$, abelian group], MathObj{$r$-module, $n$, any}]
thenassert[MathObj{sequence, $$ \label{equation-2ndex} m_1\otimes n\xrightarrow{f \otimes 1} m_2\otimes n \xrightarrow{g \otimes 1} m_3\otimes n \to 0 $$}, exact, is]
[other words]
assert[MathObj{functor, $- \otimes_r n$}, [right exact], is]
[that]
gerund[tensoring]
assert[np[[each term], [in, MathObj{sequence, original, right exact}]], exactness, preserves]
letbe[symb[$r$, ring], MathObj{ring, $r$}]
letbe[conj_symb[symb[$m$, $a$-module], symb[$n$]], MathObj{$r$-modules}]
Ifassert[conj_symb[symb[$n$], symb[$m$, $a$-module]], finite, are]
then]
MathObj{$m \otimes_r n$}]
Ifassert[conj_symb[symb[$n$], symb[$m$, $a$-module]], [finitely presented], are]
then]
MathObj{$m \otimes_r n$}]
letbe[symb[$m$, $a$-module], MathObj{$r$-module, $m$}]
thenassert[conj_ent[MathObj{$s^{-1}r$-modules, $s^{-1}m$}, MathObj{$s^{-1}r \otimes_r m$}], [canonically isomorphic], are]
and[and]
assert[MathObj{isomorphism, $f : s^{-1}r \otimes_r m \to s^{-1}m$, canonical}, phrase[partiby[given by], expr[$$ f((a/s) \otimes m) = am/s, \forall \in r, m \in m, s \in s $$]], is]
letbe[MathObj{$m, n$}, MathObj{$r$-modules}]
thenassert[there, MathObj{$s^{-1}r$-module isomorphism, $f : s^{-1}m \otimes_{s^{-1}r}s^{-1}n \to s^{-1}(m \otimes_r n)$, canonical}, is]
phrase[partiby[given by], expr[$$ f((m/s)\otimes(n/t)) = (m \otimes n)/st $$]]
